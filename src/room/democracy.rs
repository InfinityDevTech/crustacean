use log::info;
use screeps::{
    game,
    look::{self, LookResult},
    HasPosition, Room, RoomPosition, StructureType, Terrain,
};

use crate::{
    memory::ScreepsMemory,
    room::{
        cache::tick_cache::{resources, traffic, RoomCache},
        creeps::{local::hauler, organizer, recovery::recover_creeps},
        planning::room::{plan_room, structure_visuals::RoomVisualExt},
        tower,
        visuals::run_full_visuals,
    },
    traits::room::RoomExtensions,
};

use super::planning::{creep::miner::formulate_miner, room::construction::{get_rcl_2_plan, get_rcl_3_plan, get_rcl_4_plan, get_rcl_5_plan, get_rcl_6_plan, get_rcl_7_plan, get_rcl_8_plan, get_roads_and_ramparts}};

pub fn start_government(room: Room, memory: &mut ScreepsMemory) {
    // Caches various things, like resources
    // Caches structures and other creep things
    let mut room_cache = RoomCache::new_from_room(&room, memory, room.my());

    if room.my() {
        info!("[GOVERNMENT] Starting government for room: {}", room.name());

        if !memory.rooms.contains_key(&room.name()) && !plan_room(&room, memory) {
            return;

        }


        resources::haul_containers(&mut room_cache);

        // Check for dropped resources, making requests for each
        // Run haulers to process the requests generated by structures earlier
        room_cache
            .resources
            .haul_dropped_resources(&mut room_cache.hauling);
        room_cache.hauling.haul_ruins(&room_cache.structures);
        room_cache.hauling.haul_storage(&room_cache.structures);
        room_cache.structures.temp(&mut room_cache.hauling);

        // Run creeps and other structures
        // Does NOT run haulers, as they need to be done last
        // Reasoning for this decision is below
        tower::run_towers(&room, &mut room_cache);
        organizer::run_creeps(&room, memory, &mut room_cache);

        // Run spawns
        // TODO: Get a better spawn implementation
        let _ = formulate_miner(&room, memory, &mut room_cache);

        for creep in room_cache.hauling.haulers.clone() {
            let creep = game::creeps().get(creep.to_string()).unwrap();
            hauler::run_creep(&creep, memory, &mut room_cache);
        }

        // Recover creeps not existing in memory
        // Only works for haulers as of right now
        // All other un-recoverables get suicided
        if game::time() % 10 == 0 {
            recover_creeps(memory);
        }

        run_crap_planner_code(&room, memory, &room_cache);
        run_full_visuals(&room, memory, &mut room_cache);
    } else {
        organizer::run_creeps(&room, memory, &mut room_cache);
    }
    let start = game::cpu::get_used();
    traffic::run_movement(&mut room_cache);

    info!(
        "  [TRAFFIX] Traffic took: {:.4} with {} intents",
        game::cpu::get_used() - start,
        room_cache.traffic.move_intents
    );
    room_cache.write_cache_to_heap(&room);
}

pub fn run_crap_planner_code(room: &Room, memory: &mut ScreepsMemory, room_cache: &RoomCache) {
    let _coords = room_cache.structures.spawns.values().next().unwrap().pos();
    let _viz = RoomVisualExt::new(room.name());

    if game::cpu::bucket() < 500 {
        return;
    }

    if !memory.rooms.get(&room.name()).unwrap().planned
        || (memory.rooms.get(&room.name()).unwrap().rcl != room.controller().unwrap().level())
    {

        let structures = match room.controller().unwrap().level() {
            2 => get_rcl_2_plan(),
            3 => get_rcl_3_plan(),
            4 => get_rcl_4_plan(),
            5 => get_rcl_5_plan(),
            6 => get_rcl_6_plan(),
            7 => get_rcl_7_plan(),
            8 => get_rcl_8_plan(),
            _ => get_roads_and_ramparts(),
        };

        for structure in structures {
            let offset_x = room_cache.structures.spawns.values().next().unwrap().pos().x();
            let offset_y = room_cache.structures.spawns.values().next().unwrap().pos().y();

            let pos = RoomPosition::new(structure.0 as u8 + offset_x.u8(), structure.1 as u8 + offset_y.u8(), room.name());
            let _ = room.create_construction_site(pos.x(), pos.y(), structure.2, None);
        }

        // Plan container around source and controller
        let controller = &room_cache.structures.controller;
        let sources = &room_cache.resources.sources;

        let cp = controller.as_ref().unwrap().controller.pos();
        let controller_looked = room.look_for_at_area(
            look::TERRAIN,
            cp.y().u8() - 2,
            cp.x().u8() - 2,
            cp.y().u8() + 2,
            cp.x().u8() + 2,
        );

        for pos in controller_looked {
            if let LookResult::Terrain(terrain) = pos.look_result {
                if Terrain::Plain != terrain || Terrain::Swamp != terrain {
                    continue;
                }

                let pos = RoomPosition::new(pos.x, pos.y, room.name());
                if pos.get_range_to_xy(cp.x().u8(), cp.y().u8()) != 2 {
                    continue;
                }

                let _ =
                    room.create_construction_site(pos.x(), pos.y(), StructureType::Container, None);
                break;
            }
        }

        for source in sources {
            let source = game::get_object_by_id_typed(&source.id).unwrap();

            let x = source.pos().x().u8();
            let y = source.pos().y().u8();

            let looked = room.look_for_at_area(look::TERRAIN, y - 1, x - 1, y + 1, x + 1);
            for pos in looked {
                if let LookResult::Terrain(terrain) = pos.look_result {
                    if Terrain::Plain != terrain || Terrain::Swamp != terrain {
                        continue;
                    }
                    let res =
                        room.create_construction_site(pos.x, pos.y, StructureType::Container, None);
                    if res.is_ok() {
                        break;
                    }
                }
            }
        }
        memory.rooms.get_mut(&room.name()).unwrap().planned = true;
        memory.rooms.get_mut(&room.name()).unwrap().rcl = room.controller().unwrap().level();
    }
}
