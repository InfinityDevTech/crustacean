use log::info;
use screeps::{
    game, look::{self, LookResult}, pathfinder::MultiRoomCostResult, HasPosition, LocalCostMatrix, Room, RoomName, RoomPosition, RoomXY, StructureType, Terrain
};

use crate::{
    combat::{hate_handler, rank_room}, memory::ScreepsMemory, room::{
        cache::tick_cache::{resources, traffic, RoomCache},
        creeps::{local::hauler, organizer, recovery::recover_creeps},
        planning::room::{plan_room, remotes, structure_visuals::RoomVisualExt},
        tower,
        visuals::run_full_visuals,
    }, traits::room::RoomExtensions
};

use super::planning::{creep::miner::formulate_miner, room::construction::{get_rcl_2_plan, get_rcl_3_plan, get_rcl_4_plan, get_rcl_5_plan, get_rcl_6_plan, get_rcl_7_plan, get_rcl_8_plan, get_roads_and_ramparts}};

pub fn start_government(room: Room, memory: &mut ScreepsMemory) {
    // Caches various things, like resources
    // Caches structures and other creep things
    let mut room_cache = RoomCache::new_from_room(&room, memory, room.my());

    if room.my() {
        info!("[GOVERNMENT] Starting government for room: {}", room.name());

        if !memory.rooms.contains_key(&room.name()) && !plan_room(&room, memory) {
            return;

        }

        // Check for dropped resources, making requests for each
        // Run haulers to process the requests generated by structures earlier
        resources::haul_containers(&mut room_cache);
        room_cache
            .resources
            .haul_dropped_resources(&mut room_cache.hauling);
        room_cache.hauling.haul_ruins(&room_cache.structures);
        room_cache.hauling.haul_storage(&room_cache.structures);
        room_cache.structures.temp(&mut room_cache.hauling);

        // Run creeps and other structures
        // Does NOT run haulers, as they need to be done last
        // Reasoning for this decision is below
        tower::run_towers(&room, &mut room_cache);
        organizer::run_creeps(&room, memory, &mut room_cache);

        // Run spawns
        // TODO: Get a better spawn implementation
        let _ = formulate_miner(&room, memory, &mut room_cache);

        // Run haulers
        // Haulers are done last as they need to know what to haul
        for creep in room_cache.hauling.haulers.clone() {
            let creep = game::creeps().get(creep.to_string()).unwrap();
            hauler::run_creep(&creep, memory, &mut room_cache);
        }

        // Recover creeps not existing in memory
        // Only works for haulers as of right now
        // All other un-recoverables get suicided
        if game::time() % 10 == 0 {
            recover_creeps(memory);
        }

        run_crap_planner_code(&room, memory, &room_cache);
        run_full_visuals(&room, memory, &mut room_cache);

        if memory.rooms.get(&room.name()).unwrap().remotes.len() < 2 {
            let remotes = remotes::fetch_possible_remotes(&room, memory, &mut room_cache);

            
        }
    } else {
        rank_room::rank_room(&room, memory, &mut room_cache);
        // Room is NOT mine, therefore we should run creeps
        // Traffic is run on every room, so no need to put it here
        organizer::run_creeps(&room, memory, &mut room_cache);
    }

    hate_handler::process_room_event_log(&room, memory, &mut room_cache);

    let start = game::cpu::get_used();
    traffic::run_movement(&mut room_cache);

    info!(
        "  [TRAFFIX] Traffic took: {:.4} with {} intents",
        game::cpu::get_used() - start,
        room_cache.traffic.move_intents
    );
    room_cache.write_cache_to_heap(&room);
}

pub fn remote_path_call(room_name: RoomName) -> MultiRoomCostResult {
    let mut matrix = LocalCostMatrix::new();
    let terrain = game::map::get_room_terrain(room_name);

    if let Some(terrain) = terrain {
        for x in 0..50 {
            for y in 0..50 {
                let tile = terrain.get(x, y);
                let xy = unsafe { RoomXY::unchecked_new(x, y) };
                match tile {
                    Terrain::Plain => {
                        matrix.set(xy, 1);
                    }
                    Terrain::Swamp => {
                        matrix.set(xy, 5);
                    }
                    Terrain::Wall => {
                        matrix.set(xy, 255);
                    }
            }
       }
    }
}
    MultiRoomCostResult::CostMatrix(matrix.into())
}


pub fn run_crap_planner_code(room: &Room, memory: &mut ScreepsMemory, room_cache: &RoomCache) {
    let _coords = room_cache.structures.spawns.values().next().unwrap().pos();
    let _viz = RoomVisualExt::new(room.name());

    if game::cpu::bucket() < 500 {
        return;
    }

    if !memory.rooms.get(&room.name()).unwrap().planned
        || (memory.rooms.get(&room.name()).unwrap().rcl != room.controller().unwrap().level())
    {

        let structures = match room.controller().unwrap().level() {
            2 => get_rcl_2_plan(),
            3 => get_rcl_3_plan(),
            4 => get_rcl_4_plan(),
            5 => get_rcl_5_plan(),
            6 => get_rcl_6_plan(),
            7 => get_rcl_7_plan(),
            8 => get_rcl_8_plan(),
            _ => get_roads_and_ramparts(),
        };

        for structure in structures {
            let offset_x = room_cache.structures.spawns.values().next().unwrap().pos().x();
            let offset_y = room_cache.structures.spawns.values().next().unwrap().pos().y();

            let pos = RoomPosition::new(structure.0 as u8 + offset_x.u8(), structure.1 as u8 + offset_y.u8(), room.name());
            let _ = room.create_construction_site(pos.x(), pos.y(), structure.2, None);
        }

        // Plan container around source and controller
        let controller = &room_cache.structures.controller;
        let sources = &room_cache.resources.sources;

        let cp = controller.as_ref().unwrap().controller.pos();
        let controller_looked = room.look_for_at_area(
            look::TERRAIN,
            cp.y().u8() - 2,
            cp.x().u8() - 2,
            cp.y().u8() + 2,
            cp.x().u8() + 2,
        );

        for pos in controller_looked {
            if let LookResult::Terrain(terrain) = pos.look_result {
                if Terrain::Plain != terrain || Terrain::Swamp != terrain {
                    continue;
                }

                let pos = RoomPosition::new(pos.x, pos.y, room.name());
                if pos.get_range_to_xy(cp.x().u8(), cp.y().u8()) != 2 {
                    continue;
                }

                let _ =
                    room.create_construction_site(pos.x(), pos.y(), StructureType::Container, None);
                break;
            }
        }

        for source in sources {
            let source = game::get_object_by_id_typed(&source.id).unwrap();

            let x = source.pos().x().u8();
            let y = source.pos().y().u8();

            let looked = room.look_for_at_area(look::TERRAIN, y - 1, x - 1, y + 1, x + 1);
            for pos in looked {
                if let LookResult::Terrain(terrain) = pos.look_result {
                    if Terrain::Plain != terrain || Terrain::Swamp != terrain {
                        continue;
                    }
                    let res =
                        room.create_construction_site(pos.x, pos.y, StructureType::Container, None);
                    if res.is_ok() {
                        break;
                    }
                }
            }
        }
        memory.rooms.get_mut(&room.name()).unwrap().planned = true;
        memory.rooms.get_mut(&room.name()).unwrap().rcl = room.controller().unwrap().level();
    }
}
