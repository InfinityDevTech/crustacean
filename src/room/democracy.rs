use log::info;
use screeps::{find, game, look::{self, LookResult}, HasPosition, Room, RoomVisual, StructureType, Terrain};
use wasm_bindgen::convert::IntoWasmAbi;

use crate::{memory::ScreepsMemory, room::{cache::RoomCache, creeps::{local::hauler, organizer, recovery::recover_creeps}, planning::room::{construction::get_bunker_plan, structure_visuals::RoomVisualExt}, tower}};

use super::planning::creep::miner::formulate_miner;

pub fn start_government(room: Room, memory: &mut ScreepsMemory) {
    info!("[GOVERNMENT] Starting government for room: {}", room.name());

    // Caches various things, like resources
    // Caches structures and other creep things
    let mut cache = RoomCache::new_from_room(&room, memory);

    cache.structures.check_containers(&mut cache.hauling);

    // Run creeps and other structures
    // Does NOT run haulers, as they need to be done last
    // Reasoning for this decision is below
    tower::run_towers(&room, &mut cache);
    organizer::run_creeps(&room, memory, &mut cache);

    // Run spawns
    // TODO: Get a better spawn implementation
    let _ = formulate_miner(&room, memory, &mut cache);

    // Check for dropped resources, making requests for each
    // Run haulers to process the requests generated by structures earlier
    cache.resources.haul_dropped_resources(&mut cache.hauling);
    cache.structures.temp(&mut cache.hauling);
    for creep in cache.hauling.haulers.clone().iter() {
        let creep = game::creeps().get(creep.to_string()).unwrap();
        hauler::run_creep(&creep, memory, &mut cache);
    }

    // Recover creeps not existing in memory
    // Only works for haulers as of right now
    // All other un-recoverables get suicided
    if game::time() % 10 == 0 {
        recover_creeps(memory);
    }

    let coords = (27, 17);
    let mut things = get_bunker_plan();
    let mut viz = RoomVisualExt::new(room.name());

    for thing in things.clone().iter() {
        let x_offset = thing.0 + coords.0;
        let y_offset = thing.1 + coords.1;
        //viz.structure(x_offset.into(), y_offset.into(), thing.2, 0.5);
        //let _ = room.create_construction_site(x_offset as u8, y_offset as u8, thing.2, None);

        if !memory.rooms.get(&room.name()).unwrap().planned && room.controller().unwrap().level() <=1 {
            things.retain(|s| { s.2 == StructureType::Container });

            for thing in &things {
                let _ = room.create_construction_site(x_offset as u8, y_offset as u8, StructureType::Container, None);
            }

            // Plan container around source and controller
            let controller = &cache.structures.controller;
            let sources = &cache.structures.sources;

            let cp = controller.as_ref().unwrap().pos();
            let controller_looked = room.look_for_at_area(look::TERRAIN, cp.y().u8() - 1, cp.x().u8() - 1, cp.y().u8() + 1, cp.x().u8() + 1);

            for pos in controller_looked {
                if let LookResult::Terrain(terrain) = pos.look_result {
                    if Terrain::Plain != terrain { continue; }
                    let _ = room.create_construction_site(pos.x, pos.y, StructureType::Container, None);
                    break;
                }
            }

            for source in sources {
                let source = game::get_object_by_id_typed(&source.id).unwrap();

                let x = source.pos().x().u8();
                let y = source.pos().y().u8();

                let looked = room.look_for_at_area(look::TERRAIN, y - 1, x - 1, y + 1, x + 1);
                for pos in looked {
                    if let LookResult::Terrain(terrain) = pos.look_result {
                        if Terrain::Plain != terrain { continue; }
                        let _ = room.create_construction_site(pos.x, pos.y, StructureType::Container, None);
                    }
                }
            }
        }
    }
}
