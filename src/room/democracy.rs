use log::info;
use screeps::{
    game, look::{self, LookResult}, pathfinder::MultiRoomCostResult, HasPosition, LocalCostMatrix, MapTextStyle, MapVisual, Position, Room, RoomCoordinate, RoomName, RoomPosition, RoomXY, StructureType, Terrain
};

use crate::{
    combat::{self, hate_handler, rank_room}, heap, memory::{Role, ScreepsMemory}, room::{
        cache::tick_cache::{hauling, resources, RoomCache}, creeps::{organizer, recovery::recover_creeps}, planning::room::{plan_room, remotes, structure_visuals::RoomVisualExt}, tower, visuals::run_full_visuals
    }, traits::{intents_tracking::RoomExtensionsTracking, room::RoomExtensions}
};

use super::{
    cache::tick_cache::CachedRoom, links, planning::{self, room::construction::{
            get_rcl_2_plan, get_rcl_3_plan, get_rcl_4_plan, get_rcl_5_plan, get_rcl_6_plan,
            get_rcl_7_plan, get_rcl_8_plan, get_roads_and_ramparts,
        }}, visuals::visualise_room_visual
};

//#[cfg_attr(feature = "profile", screeps_timing_annotate::timing)]

// TODO:
// Separate logic of the room types, eg
// Owned - Remote - Unknown - Enemy - (Potentially, Ally?)
// Change the data stored for scouted rooms, such as safemode, MAX rcl
// Potentially attempt to estimate where the spawn battery is by:
//  Averaging the positions of all the spawns, get the base center
pub fn start_government(room: Room, memory: &mut ScreepsMemory, cache: &mut RoomCache) {
    let starting_cpu = game::cpu::get_used();

    if !room.my() && game::cpu::bucket() < 1000 {
        info!("[{}] Skipping execution, bucket is too low...", room.name());

        return;
    }

    if room.my() && !memory.rooms.contains_key(&room.name()) && !plan_room(&room, memory, cache) {
        return;
    }

    visualise_room_visual(&room.name());
    // Caches various things, like resources
    // Caches structures and other creep things
    cache.create_if_not_exists(&room, memory, None);

    if room.my() {
        info!("[GOVERNMENT] Starting government for room: {}", room.name());

        if !memory.rooms.contains_key(&room.name()) || !cache.rooms.contains_key(&room.name()) {
            return;
        }

        cache.my_rooms.push(room.name());

        {
            let cached_room = cache.rooms.get_mut(&room.name()).unwrap();
            // Check for dropped resources, making requests for each
            // Run haulers to process the requests generated by structures earlier
            resources::haul_containers(cached_room);
            resources::haul_dropped_resources(cached_room);
            hauling::haul_extensions(cached_room);
            hauling::haul_ruins(cached_room);
            hauling::haul_tombstones(cached_room);
            hauling::haul_storage(cached_room);
            hauling::haul_spawn(cached_room);

            links::balance_links(&room, cached_room);

            // Run creeps and other structures
            // Does NOT run haulers, as they need to be done last
            // Reasoning for this decision is below
            tower::run_towers(cached_room);
        }

        // Makes hauling requests for the rooms remotes :)
        resources::haul_remotes(&room, memory, cache);

        organizer::run_creeps(&room, memory, cache);

        let pre_hauler_cpu = game::cpu::get_used();

        if let Some(room) = cache.rooms.get_mut(&room.name()) {
            room.stats.cpu_creeps += game::cpu::get_used() - pre_hauler_cpu;
        }

        if let Some(hauler_cpu_usage) = cache.rooms.get_mut(&room.name()).unwrap().stats.cpu_usage_by_role.get_mut(&Role::Hauler) {
            *hauler_cpu_usage += game::cpu::get_used() - pre_hauler_cpu;
        }

        for flag in game::flags().values() {
            if flag.name().starts_with("forceCenter") {
                let pos = flag.pos();

                if flag.pos().room_name() == room.name() {
                    let room_cache = cache.rooms.get_mut(&room.name()).unwrap();
                    let room_memory = memory.rooms.get_mut(&room.name()).unwrap();

                    room_cache.spawn_center = Some(pos.xy());
                    room_memory.spawn_center = pos.xy();
                }
            }
        }

        // Recover creeps not existing in memory
        // Only works for haulers as of right now
        // All other un-recoverables get suicided
        if game::time() % 10 == 0 {
            recover_creeps(memory);
        }

        {
            let room_cache = cache.rooms.get_mut(&room.name()).unwrap();

            run_crap_planner_code(&room, memory, room_cache);
            run_full_visuals(&room, memory, room_cache);

            let mut lifetime = 0;
            {
                lifetime = *heap().heap_lifetime.lock().unwrap();
            }

            let room_memory = memory.rooms.get_mut(&room.name()).unwrap();

            if (room_memory.remotes.len() < 5 || game::time() % 3000 == 0 || lifetime == 0) && game::cpu::bucket() > 5000 {
                let remotes = remotes::fetch_possible_remotes(&room, memory, room_cache);
                info!("  [REMOTES] Remote re-scan triggered, found {} remotes", remotes.len());
            }

            room_cache.stats.spawning_stats(&mut room_cache.structures);
        }
    } else {
        // Room is NOT mine, therefore we should run creeps
        // Traffic is run on every room, so no need to put it here
        organizer::run_creeps(&room, memory, cache);

        if let Some(scouted_room) = memory.scouted_rooms.get(&room.name()) {
            if scouted_room.last_scouted < game::time() - 100 {
                rank_room::scout_room(&room, memory, cache.rooms.get_mut(&room.name()).unwrap());
            }
        } else {
            rank_room::scout_room(&room, memory, cache.rooms.get_mut(&room.name()).unwrap());
        }
    }

    hate_handler::process_room_event_log(&room, memory, cache);

    // Match these haulers to their tasks, that way we can run them
    //room_cache.hauling.match_haulers(memory, &room.name());

    if room.my() {
        let end_cpu = game::cpu::get_used();
        let room_cache = cache.rooms.get_mut(&room.name()).unwrap();

        let controller = room.controller().unwrap();
        room_cache.stats.rcl = controller.level();
        room_cache.stats.rcl_progress = controller.progress();
        room_cache.stats.rcl_progress_total = controller.progress_total();

        room_cache.stats.write_to_memory(memory, room.name(), end_cpu - starting_cpu);
    }
}

#[cfg_attr(feature = "profile", screeps_timing_annotate::timing)]
pub fn remote_path_call(room_name: RoomName) -> MultiRoomCostResult {
    let mut matrix = LocalCostMatrix::new();
    let terrain = game::map::get_room_terrain(room_name);

    if let Some(terrain) = terrain {
        for x in 0..50 {
            for y in 0..50 {
                let tile = terrain.get(x, y);
                let xy = unsafe { RoomXY::unchecked_new(x, y) };
                match tile {
                    Terrain::Plain => {
                        matrix.set(xy, 1);
                    }
                    Terrain::Swamp => {
                        matrix.set(xy, 5);
                    }
                    Terrain::Wall => {
                        matrix.set(xy, 255);
                    }
                }
            }
        }
    }
    MultiRoomCostResult::CostMatrix(matrix.into())
}

#[cfg_attr(feature = "profile", screeps_timing_annotate::timing)]
pub fn run_crap_planner_code(room: &Room, memory: &mut ScreepsMemory, room_cache: &CachedRoom) {

    if game::cpu::bucket() < 500 {
        return;
    }

    if game::cpu::bucket() > 1000 && game::time() % 1000 == 0 {
        let stuffs = get_roads_and_ramparts();

        let pos = room_cache.spawn_center.unwrap();

        let offset_x = pos.x;
        let offset_y = unsafe { RoomCoordinate::unchecked_new(pos.y.u8() + 1) };

        let should_rampart = room_cache.structures.storage.is_some() && room_cache.structures.controller.as_ref().unwrap().controller.level() >= 4;
        let should_road = room_cache.structures.controller.as_ref().unwrap().controller.level() > 3;

        if !should_road {
            return;
        } else {
            planning::room::roads::plan_main_room_roads(room, room_cache, memory);
        }

        for structure in stuffs {

            if !should_rampart && structure.2 == StructureType::Rampart {
                continue;
            }

            let pos = RoomPosition::new(
                structure.0 as u8 + offset_x.u8(),
                structure.1 as u8 + offset_y.u8(),
                room.name(),
            );
            let _ = room.ITcreate_construction_site(pos.x(), pos.y(), structure.2, None);
        }
    }

    if !memory.rooms.get(&room.name()).unwrap().planned
        || (memory.rooms.get(&room.name()).unwrap().rcl != room.controller().unwrap().level())
    {
        let level = room.controller().unwrap().level();

        memory.rooms.get_mut(&room.name()).unwrap().rcl_times.insert(level, game::time());

        let structures = match room.controller().unwrap().level() {
            2 => get_rcl_2_plan(),
            3 => get_rcl_3_plan(),
            4 => get_rcl_4_plan(),
            5 => get_rcl_5_plan(),
            6 => get_rcl_6_plan(),
            7 => get_rcl_7_plan(),
            8 => get_rcl_8_plan(),
            _ => get_roads_and_ramparts(),
        };

        for structure in structures {
            if room_cache.structures.spawns.is_empty() {
                return;
            }

            let offset_x = room_cache
                .structures
                .spawns
                .values()
                .next()
                .unwrap()
                .pos()
                .x();
            let offset_y = room_cache
                .structures
                .spawns
                .values()
                .next()
                .unwrap()
                .pos()
                .y();

            let pos = RoomPosition::new(
                structure.0 as u8 + offset_x.u8(),
                structure.1 as u8 + offset_y.u8(),
                room.name(),
            );
            let _ = room.ITcreate_construction_site(pos.x(), pos.y(), structure.2, None);
        }

        // Plan container around source and controller
        let controller = &room_cache.structures.controller;
        let sources = &room_cache.resources.sources;

        let cp = controller.as_ref().unwrap().controller.pos();
        let controller_looked = room.look_for_at_area(
            look::TERRAIN,
            cp.y().u8() - 2,
            cp.x().u8() - 2,
            cp.y().u8() + 2,
            cp.x().u8() + 2,
        );

        for pos in controller_looked {
            if let LookResult::Terrain(terrain) = pos.look_result {
                if Terrain::Plain != terrain || Terrain::Swamp != terrain {
                    continue;
                }

                let pos = RoomPosition::new(pos.x, pos.y, room.name());
                if pos.get_range_to_xy(cp.x().u8(), cp.y().u8()) != 2 {
                    continue;
                }

                let _ =
                    room.ITcreate_construction_site(pos.x(), pos.y(), StructureType::Container, None);
                break;
            }
        }

        for source in sources {
            let x = source.source.pos().x().u8();
            let y = source.source.pos().y().u8();

            let looked = room.look_for_at_area(look::TERRAIN, y - 1, x - 1, y + 1, x + 1);
            for pos in looked {
                if let LookResult::Terrain(terrain) = pos.look_result {
                    if Terrain::Plain != terrain || Terrain::Swamp != terrain {
                        continue;
                    }
                    let res =
                        room.ITcreate_construction_site(pos.x, pos.y, StructureType::Container, None);
                    if res.is_ok() {
                        break;
                    }
                }
            }
        }
        memory.rooms.get_mut(&room.name()).unwrap().planned = true;
        memory.rooms.get_mut(&room.name()).unwrap().rcl = room.controller().unwrap().level();
    }
}
