use log::info;
use screeps::{game, look::{self, LookResult}, HasPosition, Room, StructureType, Terrain};

use crate::{memory::ScreepsMemory, room::{cache::tick_cache::{traffic::{TrafficCache, TrafficProcs}, RoomCache}, creeps::{local::hauler, organizer, recovery::recover_creeps}, planning::room::{construction::get_bunker_plan, structure_visuals::RoomVisualExt}, tower}};

use super::planning::creep::miner::formulate_miner;

pub fn start_government(room: Room, memory: &mut ScreepsMemory) {
    let starting_cpu = game::cpu::get_used();
    info!("[GOVERNMENT] Starting government for room: {}", room.name());

    // Caches various things, like resources
    // Caches structures and other creep things
    let mut room_cache = RoomCache::new_from_room(&room, memory);

    room_cache.structures.check_containers(&mut room_cache.hauling);

    // Check for dropped resources, making requests for each
    // Run haulers to process the requests generated by structures earlier
    room_cache.resources.haul_dropped_resources(&mut room_cache.hauling);
    room_cache.hauling.haul_ruins(&room_cache.structures);
    room_cache.structures.temp(&mut room_cache.hauling);

    // Run creeps and other structures
    // Does NOT run haulers, as they need to be done last
    // Reasoning for this decision is below
    tower::run_towers(&room, &mut room_cache);
    organizer::run_creeps(&room, memory, &mut room_cache);

    // Run spawns
    // TODO: Get a better spawn implementation
    let _ = formulate_miner(&room, memory, &mut room_cache);

    for creep in room_cache.hauling.haulers.clone() {
        let creep = game::creeps().get(creep.to_string()).unwrap();
        hauler::run_creep(&creep, memory, &mut room_cache);
    }

    // Recover creeps not existing in memory
    // Only works for haulers as of right now
    // All other un-recoverables get suicided
    if game::time() % 10 == 0 {
        recover_creeps(memory);
    }

    let coords = room_cache.structures.spawns.values().next().unwrap().pos();
    let things = get_bunker_plan();
    let _viz = RoomVisualExt::new(room.name());

    for thing in things.iter() {
        let x_offset = thing.0 + coords.x().u8() as i8;
        let y_offset = thing.1 + coords.y().u8() as i8;
        //viz.structure(x_offset.into(), y_offset.into(), thing.2, 0.5);
        //let _ = room.create_construction_site(x_offset as u8, y_offset as u8, thing.2, None);

        if !memory.rooms.get(&room.name()).unwrap().planned || (memory.rooms.get(&room.name()).unwrap().rcl != room.controller().unwrap().level()) {
            //things.retain(|s| { s.2 == StructureType::Container });

            for thing in &things {
                let _ = room.create_construction_site(x_offset as u8, y_offset as u8, thing.2, None);
            }

            // Plan container around source and controller
            let controller = &room_cache.structures.controller;
            let sources = &room_cache.structures.sources;

            let cp = controller.as_ref().unwrap().controller.pos();
            let controller_looked = room.look_for_at_area(look::TERRAIN, cp.y().u8() - 1, cp.x().u8() - 1, cp.y().u8() + 1, cp.x().u8() + 1);

            for pos in controller_looked {
                if let LookResult::Terrain(terrain) = pos.look_result {
                    if Terrain::Plain != terrain { continue; }
                    let _ = room.create_construction_site(pos.x, pos.y, StructureType::Container, None);
                    break;
                }
            }

            for source in sources {
                let source = game::get_object_by_id_typed(&source.id).unwrap();

                let x = source.pos().x().u8();
                let y = source.pos().y().u8();

                let looked = room.look_for_at_area(look::TERRAIN, y - 1, x - 1, y + 1, x + 1);
                for pos in looked {
                    if let LookResult::Terrain(terrain) = pos.look_result {
                        if Terrain::Plain != terrain { continue; }
                        let res = room.create_construction_site(pos.x, pos.y, StructureType::Container, None);
                        if res.is_ok() {
                            break;
                        }
                    }
                }
            }
            memory.rooms.get_mut(&room.name()).unwrap().planned = true;
            memory.rooms.get_mut(&room.name()).unwrap().rcl = room.controller().unwrap().level();
        }
    }

    // Must be done LAST, traffic managemnet
    // Provided by Harabi
    // https://github.com/sy-harabi/Screeps-Traffic-Manager
    let start = game::cpu::get_used();

    TrafficProcs::run_movement(&mut room_cache);

    info!("  [TRAFFIX] Traffic took: {:.4} with {} intents", game::cpu::get_used() - start, room_cache.traffic.move_intents);

    let end_cpu = game::cpu::get_used();
    info!("  [GOVERNMENT] Finished government for room: {} in {:.4} cpu", room.name(), end_cpu - starting_cpu);
}
